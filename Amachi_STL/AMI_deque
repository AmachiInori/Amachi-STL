# pragma once
# include "AMI_allocate"
# include "initializer_list"
# include <iostream>

__ASTL_NAMESPACE_START

template <class T, class alloc, _AMI_size_t _bufsize>
class __deque_iterator : 
public __base_iterator <__ittag_random_iterator, T> {
public:
    typedef T               value_type;
    typedef T*              pointer;
    typedef T&              reference;
    typedef _AMI_size_t     size_type;
    typedef _AMI_ptrdiff_t  difference_type;
    typedef T**             map_pointer;

    typedef __deque_iterator<T, alloc, _bufsize> self;

protected:
    pointer current_element;
    pointer node_begin;
    pointer node_end;
    map_pointer current_node;

    static size_type buf_size() {
        return _bufsize != 0 ? _bufsize : (sizeof(T) < 512 ? _AMI_size_t(512 / sizeof(T)) : 1);
    }
    void set_node(map_pointer node) {
        current_node = node;
        node_begin = *node;
        node_end = node_begin + buf_size();
    }

public:
    reference& operator* () const {
        return *current_element;
    }
    pointer operator->() const {
        return current_element;
    }
    self& operator+=(size_type _length) {
        difference_type len_frm_sta = (current_element - node_begin) +  _length;
        if (len_frm_sta >= 0 && len_frm_sta < buf_size()) {
            current_element += _length;
        } else {
            difference_type node_len = len_frm_sta / buf_size();
            difference_type element_len = len_frm_sta % buf_size();
            set_node(current_node + node_len);
            current_element = node_begin + element_len;
        }
        return *this;
    }
    self& operator-=(size_type _length) {
        return this->operator+=(-_length);
    }
    self operator+(size_type _length) {
        self temp = *this;
        temp += _length;
        return temp;
    }
    self operator-(size_type _length) {
        self temp = *this;
        temp -= _length;
        return temp;
    }
    difference_type operator-(self& _other) {
        if (this->current_node == _other.current_node) {
            return difference_type(this->current_node - _other.current_node);
        } else {
            if (this->current_node > _other.current_node) {
                return difference_type(((this->current_node - _other.current_node) - 1) * buf_size() + 
                                        (this->current_element - this->node_begin) + 
                                        (_other.node_end - _other.current_element));
            } else {
                return -difference_type(((_other.current_node - this->current_node) - 1) * buf_size() + 
                                         (_other.current_element - _other.node_begin) + 
                                         (this->node_end - this->current_element));
            }
        }
    }
    self& operator++() {
        current_element++;
        if (current_element == node_end) {
            set_node(current_node + 1);
            current_element = node_begin;
        }
        return *this;
    }
    self operator++(int) {
        self old = *this;
        ++(*this);
        return old;
    }
    self& operator--() {
        if (current_element == node_begin) {
            set_node(current_node - 1);
            current_node = node_end;
        }
        current_node--;
        return *this;
    }
    self operator--(int) {
        self old = *this;
        --(*this);
        return old;
    }
    reference operator[](size_type _length) {
        return *(*this + _length);
    }
    bool operator==(const self &_other) const override {
        return _other.current_element == this->current_element;
    }
    bool operator!=(const self &_other) const override {
        return _other.current_element != this->current_element;
    }
    bool operator<(const self &_other) const {
        return (this->current_node == _other.current_node ? 
                this->current_element < _other.current_element :
                this->current_node < _other.current_node);
    }
};

template <class T, class alloc = base_allocator<T>, int _bufsize = 0>
class deque {
public:
    typedef T               value_type;
    typedef T*              pointer;
    typedef T&              reference;
    typedef _AMI_size_t     size_type;
    typedef _AMI_ptrdiff_t  difference_type;
    typedef T**             map_pointer;

    typedef __deque_iterator<T, alloc, _bufsize> iterator;

protected:
    map_pointer __map;
    iterator __begin;
    iterator __end;

    size_type __map_size;

    typedef base_allocator<value_type, __secondary_allocator> node_alloc;
    typedef base_allocator<pointer, __secondary_allocator> map_alloc;

    void fill_init(size_type length, const value_type &value) {
        
    }
public:
    iterator begin() { return __begin; }
    iterator end() { return __end; }
    reference operator[](size_type __n) {
        return __begin[difference_type(__n)];
    }
    size_type size() const { return (__end - __begin); }
    size_type max_size() const { return -1; }
    bool empty() const { return __end == __begin; }
    reference front() { return *__begin; }
    reference back() { return *(__end - 1); }
};

__ASTL_NAMESPACE_END 